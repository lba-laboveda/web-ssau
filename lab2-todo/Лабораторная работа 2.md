# Лабораторная работа №2

## База данных
Установите PostgresSQL. При установке PostgresSQL запомните пароль и выберите английскую локаль чтобы избежать дальнейших проблем. 

Создайте базу данных taskdb. Создайте таблицу task, соответствующую сущности задачи. Идентификатор должен быть автогенерируемым на уровне базы данных.
```
-- Структура БД
CREATE TABLE task (
    id SERIAL PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    status VARCHAR(50) NOT NULL,
    created_at TIMESTAMP NOT NULL,
    created_by BIGINT NOT NULL
);
```

## Обновление зависимостей
Добавьте в файл pom.xml две новые зависимости:
- `postgresql`;
- `spring-boot-starter-jdbc`.

## Конфигурация подключения к базе данных
Создайте и заполните конфигурационный файл `application.properties`. Запишите в него параметры подключения к вашей базе данных.

## JDBC слой доступа к данным

Создайте класс `TaskJdbcRepository`, реализующий интерфейс `TaskRepository` из ЛР №1.
Требования:
- использовать `JdbcTemplate` или `NamedParameterJdbcTemplate`;
- запрещено использовать ORM (Hibernate, JPA);
- запрещено использовать Spring Data JDBC.

## Переключение реализаций
Реализуйте переключение между JDBC / InMemory реализациями репозитория при помощи [профилей](https://www.theserverside.com/blog/Coffee-Talk-Java-News-Stories-and-Opinions/active-spring-boot-profile-annotation-yaml-application-properties-yml-dev-prod-uat-qa-java).

## Слой бизнес-логики

Создайте класс `TaskService`, который будет отвечать за делегирование методов доступа к данным репозиторию.
В слое сервисов в методах работы с задачами необходимо реализовать следующие бизнес-правила:
1) пользователь не может иметь более 10 активных задач одновременно (статусы `OPEN` и `IN_PROGRESS`);
2) нельзя удалять задачи, созданные менее 5 минут назад.

## Контрольные вопросы
1) В чём преимущества хранения данных в реляционной БД по сравнению с in-memory структурами? Какие недостатки?

### Преимущества реляционной БД:
Постоянство данных - данные сохраняются после перезапуска приложения
Многопользовательский доступ - одновременная работа многих клиентов
Транзакционность - поддержка ACID (атомарность, согласованность, изоляция, долговечность)
Масштабируемость - работа с терабайтами данных
Безопасность - разграничение доступа на уровне БД
Восстановление после сбоев - журналы транзакций

### Недостатки:
Медленнее - операции ввода-вывода на диск (хотя есть кэширование)
Сложнее - нужно устанавливать, настраивать, администрировать
"Тяжеловесность" - требует больше ресурсов
Сетевые задержки - если БД на отдельном сервере

### In-Memory преимущества:

Максимальная скорость - данные в оперативной памяти
Простота - не требует установки и настройки
Низкие задержки - нет сетевых вызовов

### In-Memory недостатки:
Потеря данных при перезапуске
Ограниченный объем - размер оперативной памяти
Нет транзакционности (в простых реализациях)

2) Как получить автосгенерированный ID после INSERT операции?
Способ 1: KeyHolder (JdbcTemplate)
Способ 2: RETURNING clause (PostgreSQL)
Способ 3: NamedParameterJdbcTemplate

3) В чём разница между аннотациями @Component, @Service, @Repository, @Controller?

| Аннотация | Назначение | Когда использовать |
|-----------|------------|-------------------|
| **@Component** | Общий компонент Spring | Любой класс, который не подходит под другие категории |
| **@Service** | Содержит бизнес-логику | Классы сервисного слоя |
| **@Repository** | Доступ к данным, перевод исключений JDBC в Spring исключения | DAO / Repository классы |
| **@Controller** | Обработка HTTP запросов | MVC контроллеры |

Важно: Все эти аннотации являются специализациями @Component и служат для создания бинов в Spring IoC контейнере. Они имеют разное семантическое значение:

- @Repository добавляет перевод исключений JDBC в иерархию DataAccessException
- @Controller используется для компонентов, обрабатывающих веб-запросы
- @Service указывает на наличие бизнес-логики

@Component: Основная аннотация. Рекомендуется использовать в случаях, когда класс нельзя отнести к определенному слою или не нужна специфическая функциональность.
@Repository, @Service, @Controller: Являются наследниками (специализированными шаблонами) аннотации @Component.
Рекомендуется использовать их, когда можно отнести класс к определенному слою (например, DAO для @Repository).
- Они могут предоставлять дополнительную функциональность.
- Они могут иметь дополнительный смысл в будущих версиях Spring Framework.
@Controller / @RestController: Используется для веб-контроллеров, обрабатывающих HTTP-запросы (стр. 28, 36).


4) Принцип внедрения зависимостей. Принцип инверсии управления.
### Принцип инверсии управления (IoC):
IoC также известен как внедрение зависимостей (DI).
Это процесс, в котором объекты определяют свои зависимости (другие объекты, с которыми они работают) только через аргументы конструктора, аргументы фабричного метода или свойства.
Контейнер внедряет эти зависимости при создании bean-компонента.
Процесс является обратным тому, где bean-компонент сам управляет созданием экземпляров или расположением зависимостей.
### Контейнер IoC:
Интерфейс ApplicationContext представляет контейнер Spring IoC.
Он отвечает за создание, настройку и сборку компонентов (bean-компонентов).
Контейнер считывает метаданные конфигурации (XML, аннотации Java или код Java) для понимания, какие объекты создавать и как их собирать.



5) Разделение приложения на слои Repository/Service/Controller. Какова ответственность каждого слоя?

### Общая трёхуровневая архитектура:
Клиентский слой: Интерфейс пользователя (браузер, приложение).
Слой логики (Серверный): Обработка запросов/ответов, логические операции, обращения к хранилищам.
Слой данных: Сервер баз данных, хранение информации.
### В контексте Spring:
Controller (Контроллер): Предназначен для обработки запросов, пришедших по определённому адресу (HTTP-запросы от клиента). Пример: @RestController, @RequestMapping.
Service (Сервис): На слое сервисов расположена бизнес-логика обработки данных. Содержит методы для выполнения операций (например, create, findAll).
Repository (Репозиторий): Упрощает реализацию уровней доступа к данным. Интерфейсы репозиториев (например, JpaRepository) обеспечивают работу с базой данных (сохранение, поиск). Spring автоматически предоставляет реализацию.

[Клиент] → [Controller] → [Service] → [Repository] → [База данных]


| Слой | Ответственность |
|------|-----------------|
| **Controller** | - Обработка HTTP запросов<br>- Валидация входных данных<br>- Формирование HTTP ответов<br>- Маршрутизация запросов |
| **Service** | - Бизнес-логика (правила, проверки)<br>- Управление транзакциями<br>- Вызов методов репозитория<br>- Независимость от протокола передачи |
| **Repository** | - Операции с БД (CRUD)<br>- Маппинг данных в объекты<br>- Работа с конкретной БД |
| **Entity** | - Модель данных<br>- Состояние объекта |


### Многоуровневая архитектура дает следующие преимущества:
Возможность построить защиту от SQL-инъекций
Разграничение данных, к которым необходимо регулировать пользовательский доступ
Возможность модифицировать данные перед отправкой клиенту
Масштабируемость

6) Различия между JdbcTemplate / NamedParameterJdbcTemplate

| Критерий | JdbcTemplate | NamedParameterJdbcTemplate |
|----------|--------------|---------------------------|
| **Синтаксис** | `?` (позиционный) | `:name` (именованный) |
| **Читаемость** | Сложно при многих параметрах | Понятно сразу |
| **Порядок параметров** | Важен порядок | Не важен |
| **IN условия** | Сложно (нужно генерировать ?) | Просто (можно передать список) |
| **Повтор параметров** | Нужно дублировать | Можно использовать одно имя |
| **Безопасность** | Защита от SQL-инъекций | Защита от SQL-инъекций |

Пример JdbcTemplate:
`jdbcTemplate.update("INSERT INTO task (title, status) VALUES (?, ?)", title, status)`;
Пример NamedParameterJdbcTemplate:
```Map<String, Object> params = new HashMap<>();
params.put("t", title);
params.put("s", status);
namedJdbcTemplate.update("INSERT INTO task (title, status) VALUES (:t, :s)", params);
```
7) Зачем была подключена зависимость postgresql?
Зависимость postgresql содержит JDBC драйвер для PostgreSQL - библиотеку, которая позволяет Java-приложению:

- Устанавливать соединение с базой данных PostgreSQL
- Отправлять SQL-запросы
- Получать результаты выполнения запросов
- Конвертировать типы Java в типы PostgreSQL и обратно

Без этого драйвера Spring не сможет подключиться к PostgreSQL, даже если URL указан правильно, так как драйвер обеспечивает реализацию интерфейсов JDBC для конкретной СУБД.

8) Технология JDBC.
JDBC (Java Database Connectivity) - это стандартный API для взаимодействия Java-приложений с различными реляционными базами данных.
Проблемы чистого JDBC:
- Много boilerplate кода (try-catch-finally)
- Ручное управление ресурсами
- Сложная обработка исключений
- Вероятность ошибок при закрытии ресурсов
- Spring JdbcTemplate решает эти проблемы, инкапсулируя рутинные операции.

9) SQL-Injection атака и способы борьбы с ней.
SQL-Injection - это атака на сервер, при которой злоумышленник внедряет вредоносный SQL-код в запрос, что позволяет ему воздействовать на базу данных.
Способы защиты:

1. Использование PreparedStatement (параметризованные запросы)
2. Использование JdbcTemplate
3. Использование NamedParameterJdbcTemplate
Почему это работает:
При использовании PreparedStatement параметры передаются отдельно от SQL-кода, поэтому даже если в параметре есть SQL-команды, они воспринимаются как данные, а не как код. База данных обрабатывает структуру запроса отдельно от данных.

Важно: Никогда не конкатенируйте пользовательский ввод в SQL-строку! Всегда используйте параметризованные запросы.